   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init,"ax",@progbits
  11               	.global	matrix_init
  13               	matrix_init:
  14               	.LFB111:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2011 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <util/delay.h>
  24:matrix.c      **** #include "print.h"
  25:matrix.c      **** #include "debug.h"
  26:matrix.c      **** #include "util.h"
  27:matrix.c      **** #include "timer.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** #include "hhkb_avr.h"
  30:matrix.c      **** #include <avr/wdt.h>
  31:matrix.c      **** #include "suspend.h"
  32:matrix.c      **** #include "lufa.h"
  33:matrix.c      **** 
  34:matrix.c      **** 
  35:matrix.c      **** // matrix power saving
  36:matrix.c      **** #define MATRIX_POWER_SAVE       10000
  37:matrix.c      **** static uint32_t matrix_last_modified = 0;
  38:matrix.c      **** 
  39:matrix.c      **** // matrix state buffer(1:on, 0:off)
  40:matrix.c      **** static matrix_row_t *matrix;
  41:matrix.c      **** static matrix_row_t *matrix_prev;
  42:matrix.c      **** static matrix_row_t _matrix0[MATRIX_ROWS];
  43:matrix.c      **** static matrix_row_t _matrix1[MATRIX_ROWS];
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** void matrix_init(void)
  47:matrix.c      **** {
  16               		.loc 1 47 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LBB37:
  23               	.LBB38:
  24               		.file 2 "hhkb_avr.h"
   1:hhkb_avr.h    **** #ifndef HHKB_AVR_H
   2:hhkb_avr.h    **** #define HHKB_AVR_H
   3:hhkb_avr.h    **** 
   4:hhkb_avr.h    **** #include <stdint.h>
   5:hhkb_avr.h    **** #include <stdbool.h>
   6:hhkb_avr.h    **** #include <avr/io.h>
   7:hhkb_avr.h    **** #include <avr/interrupt.h>
   8:hhkb_avr.h    **** #include <util/delay.h>
   9:hhkb_avr.h    **** 
  10:hhkb_avr.h    **** 
  11:hhkb_avr.h    **** // Timer resolution check
  12:hhkb_avr.h    **** #if (1000000/TIMER_RAW_FREQ > 20)
  13:hhkb_avr.h    **** #   error "Timer resolution(>20us) is not enough for HHKB matrix scan tweak on V-USB."
  14:hhkb_avr.h    **** #endif
  15:hhkb_avr.h    **** 
  16:hhkb_avr.h    **** 
  17:hhkb_avr.h    **** /*
  18:hhkb_avr.h    ****  * HHKB Matrix I/O
  19:hhkb_avr.h    ****  *
  20:hhkb_avr.h    ****  * row:     HC4051[A,B,C]  selects scan row0-7
  21:hhkb_avr.h    ****  * row-ext: [En0,En1] row extention for JP
  22:hhkb_avr.h    ****  * col:     LS145[A,B,C,D] selects scan col0-7 and enable(D)
  23:hhkb_avr.h    ****  * key:     on: 0/off: 1
  24:hhkb_avr.h    ****  * prev:    hysteresis control: assert(1) when previous key state is on
  25:hhkb_avr.h    ****  */
  26:hhkb_avr.h    **** 
  27:hhkb_avr.h    **** 
  28:hhkb_avr.h    **** #if defined(__AVR_ATmega32U4__)
  29:hhkb_avr.h    **** /*
  30:hhkb_avr.h    ****  * For TMK HHKB alt controller(ATMega32U4)
  31:hhkb_avr.h    ****  *
  32:hhkb_avr.h    ****  * row:     PB0-2
  33:hhkb_avr.h    ****  * col:     PB3-5,6
  34:hhkb_avr.h    ****  * key:     PD7(pull-uped)
  35:hhkb_avr.h    ****  * prev:    PB7
  36:hhkb_avr.h    ****  * power:   PD4(L:off/H:on)
  37:hhkb_avr.h    ****  * row-ext: PC6,7 for HHKB JP(active low)
  38:hhkb_avr.h    ****  */
  39:hhkb_avr.h    **** static inline void KEY_ENABLE(void) { (PORTB &= ~(1<<6)); }
  40:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
  41:hhkb_avr.h    **** static inline bool KEY_STATE(void) { return (PIND & (1<<7)); }
  42:hhkb_avr.h    **** static inline void KEY_PREV_ON(void) { (PORTB |=  (1<<7)); }
  43:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTB &= ~(1<<7)); }
  44:hhkb_avr.h    **** #ifdef HHKB_POWER_SAVING
  45:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {
  46:hhkb_avr.h    ****     DDRB = 0xFF; PORTB = 0x40;          // change pins output
  47:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD |= (1<<4);    // MOS FET switch on
  48:hhkb_avr.h    ****     /* Without this wait you will miss or get false key events. */
  49:hhkb_avr.h    ****     _delay_ms(5);                       // wait for powering up
  50:hhkb_avr.h    **** }
  51:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {
  52:hhkb_avr.h    ****     /* input with pull-up consumes less than without it when pin is open. */
  53:hhkb_avr.h    ****     DDRB = 0x00; PORTB = 0xFF;          // change pins input with pull-up
  54:hhkb_avr.h    ****     DDRD |= (1<<4); PORTD &= ~(1<<4);   // MOS FET switch off
  55:hhkb_avr.h    **** }
  56:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return PORTD & (1<<4); }
  57:hhkb_avr.h    **** #else
  58:hhkb_avr.h    **** static inline void KEY_POWER_ON(void) {}
  59:hhkb_avr.h    **** static inline void KEY_POWER_OFF(void) {}
  60:hhkb_avr.h    **** static inline bool KEY_POWER_STATE(void) { return true; }
  61:hhkb_avr.h    **** #endif
  62:hhkb_avr.h    **** static inline void KEY_INIT(void)
  63:hhkb_avr.h    **** {
  64:hhkb_avr.h    ****     /* row,col,prev: output */
  65:hhkb_avr.h    ****     DDRB  = 0xFF;
  25               		.loc 2 65 0
  26 0000 8FEF      		ldi r24,lo8(-1)
  27 0002 84B9      		out 0x4,r24
  66:hhkb_avr.h    ****     PORTB = 0x40;   // unable
  28               		.loc 2 66 0
  29 0004 80E4      		ldi r24,lo8(64)
  30 0006 85B9      		out 0x5,r24
  67:hhkb_avr.h    ****     /* key: input with pull-up */
  68:hhkb_avr.h    ****     DDRD  &= ~0x80;
  31               		.loc 2 68 0
  32 0008 5798      		cbi 0xa,7
  69:hhkb_avr.h    ****     PORTD |=  0x80;
  33               		.loc 2 69 0
  34 000a 5F9A      		sbi 0xb,7
  70:hhkb_avr.h    **** #ifdef HHKB_JP
  71:hhkb_avr.h    ****     /* row extention for HHKB JP */
  72:hhkb_avr.h    ****     DDRC  |= (1<<6|1<<7);
  73:hhkb_avr.h    ****     PORTC |= (1<<6|1<<7);
  74:hhkb_avr.h    **** #else
  75:hhkb_avr.h    ****     /* input with pull up to save power */
  76:hhkb_avr.h    ****     DDRC  &= ~(1<<6|1<<7);
  35               		.loc 2 76 0
  36 000c 87B1      		in r24,0x7
  37 000e 8F73      		andi r24,lo8(63)
  38 0010 87B9      		out 0x7,r24
  77:hhkb_avr.h    ****     PORTC |=  (1<<6|1<<7);
  39               		.loc 2 77 0
  40 0012 88B1      		in r24,0x8
  41 0014 806C      		ori r24,lo8(-64)
  42 0016 88B9      		out 0x8,r24
  43               	.LBB39:
  44               	.LBB40:
  40:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
  45               		.loc 2 40 0
  46 0018 2E9A      		sbi 0x5,6
  47               	.LBE40:
  48               	.LBE39:
  49               	.LBB41:
  50               	.LBB42:
  43:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTB &= ~(1<<7)); }
  51               		.loc 2 43 0
  52 001a 2F98      		cbi 0x5,7
  53               	.LVL0:
  54 001c E0E0      		ldi r30,lo8(_matrix0)
  55 001e F0E0      		ldi r31,hi8(_matrix0)
  56               	.LVL1:
  57               	.L3:
  58               	.LBE42:
  59               	.LBE41:
  60               	.LBE38:
  61               	.LBE37:
  62               	.LBB43:
  48:matrix.c      **** #ifdef DEBUG
  49:matrix.c      ****     debug_enable = true;
  50:matrix.c      ****     debug_keyboard = true;
  51:matrix.c      **** #endif
  52:matrix.c      **** 
  53:matrix.c      ****     KEY_INIT();
  54:matrix.c      **** 
  55:matrix.c      ****     // initialize matrix state: all keys off
  56:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix0[i] = 0x00;
  63               		.loc 1 56 0 discriminator 2
  64 0020 1192      		st Z+,__zero_reg__
  65               	.LVL2:
  66 0022 80E0      		ldi r24,hi8(_matrix0+8)
  67 0024 E030      		cpi r30,lo8(_matrix0+8)
  68 0026 F807      		cpc r31,r24
  69 0028 01F4      		brne .L3
  70 002a E0E0      		ldi r30,lo8(_matrix1)
  71 002c F0E0      		ldi r31,hi8(_matrix1)
  72               	.LVL3:
  73               	.L5:
  74               	.LBE43:
  75               	.LBB44:
  57:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) _matrix1[i] = 0x00;
  76               		.loc 1 57 0 discriminator 2
  77 002e 1192      		st Z+,__zero_reg__
  78               	.LVL4:
  79 0030 80E0      		ldi r24,hi8(_matrix1+8)
  80 0032 E030      		cpi r30,lo8(_matrix1+8)
  81 0034 F807      		cpc r31,r24
  82 0036 01F4      		brne .L5
  83               	.LBE44:
  58:matrix.c      ****     matrix = _matrix0;
  84               		.loc 1 58 0
  85 0038 80E0      		ldi r24,lo8(_matrix0)
  86 003a 90E0      		ldi r25,hi8(_matrix0)
  87 003c 9093 0000 		sts matrix+1,r25
  88 0040 8093 0000 		sts matrix,r24
  59:matrix.c      ****     matrix_prev = _matrix1;
  89               		.loc 1 59 0
  90 0044 80E0      		ldi r24,lo8(_matrix1)
  91 0046 90E0      		ldi r25,hi8(_matrix1)
  92 0048 9093 0000 		sts matrix_prev+1,r25
  93 004c 8093 0000 		sts matrix_prev,r24
  94 0050 0895      		ret
  95               		.cfi_endproc
  96               	.LFE111:
  98               		.section	.text.matrix_scan,"ax",@progbits
  99               	.global	matrix_scan
 101               	matrix_scan:
 102               	.LFB112:
  60:matrix.c      **** }
  61:matrix.c      **** 
  62:matrix.c      **** uint8_t matrix_scan(void)
  63:matrix.c      **** {
 103               		.loc 1 63 0
 104               		.cfi_startproc
 105 0000 0F93      		push r16
 106               	.LCFI0:
 107               		.cfi_def_cfa_offset 3
 108               		.cfi_offset 16, -2
 109 0002 1F93      		push r17
 110               	.LCFI1:
 111               		.cfi_def_cfa_offset 4
 112               		.cfi_offset 17, -3
 113 0004 CF93      		push r28
 114               	.LCFI2:
 115               		.cfi_def_cfa_offset 5
 116               		.cfi_offset 28, -4
 117 0006 DF93      		push r29
 118               	.LCFI3:
 119               		.cfi_def_cfa_offset 6
 120               		.cfi_offset 29, -5
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 4 */
 124               	.L__stack_usage = 4
  64:matrix.c      ****     uint8_t *tmp;
  65:matrix.c      **** 
  66:matrix.c      ****     tmp = matrix_prev;
 125               		.loc 1 66 0
 126 0008 8091 0000 		lds r24,matrix_prev
 127 000c 9091 0000 		lds r25,matrix_prev+1
 128               	.LVL5:
  67:matrix.c      ****     matrix_prev = matrix;
 129               		.loc 1 67 0
 130 0010 2091 0000 		lds r18,matrix
 131 0014 3091 0000 		lds r19,matrix+1
 132 0018 3093 0000 		sts matrix_prev+1,r19
 133 001c 2093 0000 		sts matrix_prev,r18
  68:matrix.c      ****     matrix = tmp;
 134               		.loc 1 68 0
 135 0020 9093 0000 		sts matrix+1,r25
 136 0024 8093 0000 		sts matrix,r24
 137               	.LVL6:
 138 0028 C0E0      		ldi r28,0
 139 002a D0E0      		ldi r29,0
 140               	.LBB70:
 141               	.LBB71:
 142               	.LBB72:
  69:matrix.c      **** 
  70:matrix.c      ****     // power on
  71:matrix.c      ****     if (!KEY_POWER_STATE()) KEY_POWER_ON();
  72:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
  73:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
  74:matrix.c      ****             KEY_SELECT(row, col);
  75:matrix.c      ****             _delay_us(5);
  76:matrix.c      **** 
  77:matrix.c      ****             // Not sure this is needed. This just emulates HHKB controller's behaviour.
  78:matrix.c      ****             if (matrix_prev[row] & (1<<col)) {
  79:matrix.c      ****                 KEY_PREV_ON();
  80:matrix.c      ****             }
  81:matrix.c      ****             _delay_us(10);
  82:matrix.c      **** 
  83:matrix.c      ****             // NOTE: KEY_STATE is valid only in 20us after KEY_ENABLE.
  84:matrix.c      ****             // If V-USB interrupts in this section we could lose 40us or so
  85:matrix.c      ****             // and would read invalid value from KEY_STATE.
  86:matrix.c      ****             uint8_t last = TIMER_RAW;
  87:matrix.c      **** 
  88:matrix.c      ****             KEY_ENABLE();
  89:matrix.c      **** 
  90:matrix.c      ****             // Wait for KEY_STATE outputs its value.
  91:matrix.c      ****             // 1us was ok on one HHKB, but not worked on another.
  92:matrix.c      ****             // no   wait doesn't work on Teensy++ with pro(1us works)
  93:matrix.c      ****             // no   wait does    work on tmk PCB(8MHz) with pro2
  94:matrix.c      ****             // 1us  wait does    work on both of above
  95:matrix.c      ****             // 1us  wait doesn't work on tmk(16MHz)
  96:matrix.c      ****             // 5us  wait does    work on tmk(16MHz)
  97:matrix.c      ****             // 5us  wait does    work on tmk(16MHz/2)
  98:matrix.c      ****             // 5us  wait does    work on tmk(8MHz)
  99:matrix.c      ****             // 10us wait does    work on Teensy++ with pro
 100:matrix.c      ****             // 10us wait does    work on 328p+iwrap with pro
 101:matrix.c      ****             // 10us wait doesn't work on tmk PCB(8MHz) with pro2(very lagged scan)
 102:matrix.c      ****             _delay_us(5);
 103:matrix.c      **** 
 104:matrix.c      ****             if (KEY_STATE()) {
 105:matrix.c      ****                 matrix[row] &= ~(1<<col);
 106:matrix.c      ****             } else {
 107:matrix.c      ****                 matrix[row] |= (1<<col);
 143               		.loc 1 107 0
 144 002c 01E0      		ldi r16,lo8(1)
 145 002e 10E0      		ldi r17,0
 146               	.LVL7:
 147               	.L8:
 148               	.LBE72:
 149               	.LBE71:
 150               	.LBE70:
  63:matrix.c      **** {
 151               		.loc 1 63 0 discriminator 1
 152 0030 80E0      		ldi r24,0
 153 0032 90E0      		ldi r25,0
 154               	.LVL8:
 155               	.L20:
 156               	.LBB95:
 157               	.LBB94:
 158               	.LBB93:
 159               	.LBB73:
 160               	.LBB74:
  78:hhkb_avr.h    **** #endif
  79:hhkb_avr.h    ****     KEY_UNABLE();
  80:hhkb_avr.h    ****     KEY_PREV_OFF();
  81:hhkb_avr.h    **** 
  82:hhkb_avr.h    ****     KEY_POWER_OFF();
  83:hhkb_avr.h    **** }
  84:hhkb_avr.h    **** static inline void KEY_SELECT(uint8_t ROW, uint8_t COL)
  85:hhkb_avr.h    **** {
  86:hhkb_avr.h    ****     PORTB = (PORTB & 0xC0) | (((COL) & 0x07)<<3) | ((ROW) & 0x07);
 161               		.loc 2 86 0
 162 0034 45B1      		in r20,0x5
 163 0036 407C      		andi r20,lo8(-64)
 164 0038 4C2B      		or r20,r28
 165 003a 9C01      		movw r18,r24
 166 003c 53E0      		ldi r21,3
 167               		1:
 168 003e 220F      		lsl r18
 169 0040 331F      		rol r19
 170 0042 5A95      		dec r21
 171 0044 01F4      		brne 1b
 172 0046 422B      		or r20,r18
 173 0048 45B9      		out 0x5,r20
 174               	.LVL9:
 175               	.LBE74:
 176               	.LBE73:
 177               	.LBB75:
 178               	.LBB76:
 179               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 180               		.loc 3 245 0
 181 004a EAE1      		ldi r30,lo8(26)
 182 004c EA95      		1: dec r30
 183 004e 01F4      		brne 1b
 184 0050 00C0      		rjmp .
 185               	.LBE76:
 186               	.LBE75:
  78:matrix.c      ****             if (matrix_prev[row] & (1<<col)) {
 187               		.loc 1 78 0
 188 0052 E091 0000 		lds r30,matrix_prev
 189 0056 F091 0000 		lds r31,matrix_prev+1
 190 005a EC0F      		add r30,r28
 191 005c FD1F      		adc r31,r29
 192 005e 2081      		ld r18,Z
 193 0060 30E0      		ldi r19,0
 194 0062 082E      		mov r0,r24
 195 0064 00C0      		rjmp 2f
 196               		1:
 197 0066 3595      		asr r19
 198 0068 2795      		ror r18
 199               		2:
 200 006a 0A94      		dec r0
 201 006c 02F4      		brpl 1b
 202 006e 20FD      		sbrc r18,0
 203               	.LBB77:
 204               	.LBB78:
  42:hhkb_avr.h    **** static inline void KEY_PREV_ON(void) { (PORTB |=  (1<<7)); }
 205               		.loc 2 42 0
 206 0070 2F9A      		sbi 0x5,7
 207               	.L9:
 208               	.LVL10:
 209               	.LBE78:
 210               	.LBE77:
 211               	.LBB79:
 212               	.LBB80:
 213               		.loc 3 245 0
 214 0072 F5E3      		ldi r31,lo8(53)
 215 0074 FA95      		1: dec r31
 216 0076 01F4      		brne 1b
 217 0078 0000      		nop
 218               	.LBE80:
 219               	.LBE79:
  86:matrix.c      ****             uint8_t last = TIMER_RAW;
 220               		.loc 1 86 0
 221 007a A6B5      		in r26,0x26
 222               	.LVL11:
 223               	.LBB81:
 224               	.LBB82:
  39:hhkb_avr.h    **** static inline void KEY_ENABLE(void) { (PORTB &= ~(1<<6)); }
 225               		.loc 2 39 0
 226 007c 2E98      		cbi 0x5,6
 227               	.LVL12:
 228               	.LBE82:
 229               	.LBE81:
 230               	.LBB83:
 231               	.LBB84:
 232               		.loc 3 245 0
 233 007e 2AE1      		ldi r18,lo8(26)
 234 0080 2A95      		1: dec r18
 235 0082 01F4      		brne 1b
 236 0084 00C0      		rjmp .
 237 0086 2091 0000 		lds r18,matrix
 238 008a 3091 0000 		lds r19,matrix+1
 239               	.LBE84:
 240               	.LBE83:
 104:matrix.c      ****             if (KEY_STATE()) {
 241               		.loc 1 104 0
 242 008e 4F9B      		sbis 0x9,7
 243 0090 00C0      		rjmp .L10
 105:matrix.c      ****                 matrix[row] &= ~(1<<col);
 244               		.loc 1 105 0
 245 0092 A801      		movw r20,r16
 246 0094 082E      		mov r0,r24
 247 0096 00C0      		rjmp 2f
 248               		1:
 249 0098 440F      		lsl r20
 250               		2:
 251 009a 0A94      		dec r0
 252 009c 02F4      		brpl 1b
 253 009e 4095      		com r20
 254 00a0 F901      		movw r30,r18
 255 00a2 EC0F      		add r30,r28
 256 00a4 FD1F      		adc r31,r29
 257 00a6 5081      		ld r21,Z
 258 00a8 5423      		and r21,r20
 259 00aa 5083      		st Z,r21
 260 00ac 00C0      		rjmp .L11
 261               	.L10:
 262               		.loc 1 107 0
 263 00ae F901      		movw r30,r18
 264 00b0 EC0F      		add r30,r28
 265 00b2 FD1F      		adc r31,r29
 266 00b4 6081      		ld r22,Z
 267 00b6 A801      		movw r20,r16
 268 00b8 082E      		mov r0,r24
 269 00ba 00C0      		rjmp 2f
 270               		1:
 271 00bc 440F      		lsl r20
 272               		2:
 273 00be 0A94      		dec r0
 274 00c0 02F4      		brpl 1b
 275 00c2 642B      		or r22,r20
 276 00c4 6083      		st Z,r22
 277               	.L11:
 108:matrix.c      ****             }
 109:matrix.c      **** 
 110:matrix.c      ****             // Ignore if this code region execution time elapses more than 20us.
 111:matrix.c      ****             // MEMO: 20[us] * (TIMER_RAW_FREQ / 1000000)[count per us]
 112:matrix.c      ****             // MEMO: then change above using this rule: a/(b/c) = a*1/(b/c) = a*(c/b)
 113:matrix.c      ****             if (TIMER_DIFF_RAW(TIMER_RAW, last) > 20/(1000000/TIMER_RAW_FREQ)) {
 278               		.loc 1 113 0
 279 00c6 46B5      		in r20,0x26
 280 00c8 6A2F      		mov r22,r26
 281 00ca 70E0      		ldi r23,0
 282 00cc 4A17      		cp r20,r26
 283 00ce 00F0      		brlo .L12
 284               	.LVL13:
 285               		.loc 1 113 0 is_stmt 0 discriminator 1
 286 00d0 46B5      		in r20,0x26
 287 00d2 50E0      		ldi r21,0
 288 00d4 00C0      		rjmp .L35
 289               	.L12:
 290               		.loc 1 113 0 discriminator 2
 291 00d6 46B5      		in r20,0x26
 292 00d8 50E0      		ldi r21,0
 293 00da 4150      		subi r20,1
 294 00dc 5F4F      		sbci r21,-1
 295               	.L35:
 296 00de 461B      		sub r20,r22
 297 00e0 570B      		sbc r21,r23
 298 00e2 4630      		cpi r20,6
 299 00e4 5105      		cpc r21,__zero_reg__
 300 00e6 00F0      		brlo .L16
 114:matrix.c      ****                 matrix[row] = matrix_prev[row];
 301               		.loc 1 114 0 is_stmt 1
 302 00e8 E091 0000 		lds r30,matrix_prev
 303 00ec F091 0000 		lds r31,matrix_prev+1
 304 00f0 EC0F      		add r30,r28
 305 00f2 FD1F      		adc r31,r29
 306 00f4 4081      		ld r20,Z
 307 00f6 F901      		movw r30,r18
 308 00f8 EC0F      		add r30,r28
 309 00fa FD1F      		adc r31,r29
 310 00fc 4083      		st Z,r20
 311               	.L16:
 312               	.LVL14:
 313               	.LBB85:
 314               	.LBB86:
 315               		.loc 3 245 0
 316 00fe EAE1      		ldi r30,lo8(26)
 317 0100 EA95      		1: dec r30
 318 0102 01F4      		brne 1b
 319 0104 00C0      		rjmp .
 320               	.LBE86:
 321               	.LBE85:
 322               	.LBB87:
 323               	.LBB88:
  43:hhkb_avr.h    **** static inline void KEY_PREV_OFF(void) { (PORTB &= ~(1<<7)); }
 324               		.loc 2 43 0
 325 0106 2F98      		cbi 0x5,7
 326               	.LBE88:
 327               	.LBE87:
 328               	.LBB89:
 329               	.LBB90:
  40:hhkb_avr.h    **** static inline void KEY_UNABLE(void) { (PORTB |=  (1<<6)); }
 330               		.loc 2 40 0
 331 0108 2E9A      		sbi 0x5,6
 332               	.LVL15:
 333               	.LBE90:
 334               	.LBE89:
 335               	.LBB91:
 336               	.LBB92:
 337               		.loc 3 245 0
 338 010a EBE2      		ldi r30,lo8(299)
 339 010c F1E0      		ldi r31,hi8(299)
 340 010e 3197      		1: sbiw r30,1
 341 0110 01F4      		brne 1b
 342 0112 00C0      		rjmp .
 343 0114 0000      		nop
 344               	.LVL16:
 345 0116 0196      		adiw r24,1
 346               	.LVL17:
 347               	.LBE92:
 348               	.LBE91:
 349               	.LBE93:
  73:matrix.c      ****         for (uint8_t col = 0; col < MATRIX_COLS; col++) {
 350               		.loc 1 73 0
 351 0118 8830      		cpi r24,8
 352 011a 9105      		cpc r25,__zero_reg__
 353 011c 01F0      		breq .+2
 354 011e 00C0      		rjmp .L20
 355               	.LBE94:
 115:matrix.c      ****             }
 116:matrix.c      **** 
 117:matrix.c      ****             _delay_us(5);
 118:matrix.c      ****             KEY_PREV_OFF();
 119:matrix.c      ****             KEY_UNABLE();
 120:matrix.c      **** 
 121:matrix.c      ****             // NOTE: KEY_STATE keep its state in 20us after KEY_ENABLE.
 122:matrix.c      ****             // This takes 25us or more to make sure KEY_STATE returns to idle state.
 123:matrix.c      **** #ifdef HHKB_JP
 124:matrix.c      ****             // Looks like JP needs faster scan due to its twice larger matrix
 125:matrix.c      ****             // or it can drop keys in fast key typing
 126:matrix.c      ****             _delay_us(30);
 127:matrix.c      **** #else
 128:matrix.c      ****             _delay_us(75);
 129:matrix.c      **** #endif
 130:matrix.c      ****         }
 131:matrix.c      ****         if (matrix[row] ^ matrix_prev[row]) matrix_last_modified = timer_read32();
 356               		.loc 1 131 0
 357 0120 A091 0000 		lds r26,matrix
 358 0124 B091 0000 		lds r27,matrix+1
 359 0128 AC0F      		add r26,r28
 360 012a BD1F      		adc r27,r29
 361 012c E091 0000 		lds r30,matrix_prev
 362 0130 F091 0000 		lds r31,matrix_prev+1
 363 0134 EC0F      		add r30,r28
 364 0136 FD1F      		adc r31,r29
 365 0138 9C91      		ld r25,X
 366 013a 8081      		ld r24,Z
 367               	.LVL18:
 368 013c 9817      		cp r25,r24
 369 013e 01F0      		breq .L18
 370               		.loc 1 131 0 is_stmt 0 discriminator 1
 371 0140 0E94 0000 		call timer_read32
 372               	.LVL19:
 373 0144 6093 0000 		sts matrix_last_modified,r22
 374 0148 7093 0000 		sts matrix_last_modified+1,r23
 375 014c 8093 0000 		sts matrix_last_modified+2,r24
 376 0150 9093 0000 		sts matrix_last_modified+3,r25
 377               	.L18:
 378               	.LVL20:
 379 0154 2196      		adiw r28,1
 380               	.LVL21:
  72:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 381               		.loc 1 72 0 is_stmt 1
 382 0156 C830      		cpi r28,8
 383 0158 D105      		cpc r29,__zero_reg__
 384 015a 01F0      		breq .+2
 385 015c 00C0      		rjmp .L8
 386               	.LBE95:
 132:matrix.c      ****     }
 133:matrix.c      ****     // power off
 134:matrix.c      ****     if (KEY_POWER_STATE() &&
 135:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 387               		.loc 1 135 0 discriminator 1
 388 015e 8091 0000 		lds r24,USB_DeviceState
 134:matrix.c      ****     if (KEY_POWER_STATE() &&
 389               		.loc 1 134 0 discriminator 1
 390 0162 8530      		cpi r24,lo8(5)
 391 0164 01F0      		breq .L21
 136:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 392               		.loc 1 136 0
 393 0166 8091 0000 		lds r24,USB_DeviceState
 135:matrix.c      ****             (USB_DeviceState == DEVICE_STATE_Suspended ||
 394               		.loc 1 135 0
 395 016a 8111      		cpse r24,__zero_reg__
 396 016c 00C0      		rjmp .L22
 397               	.L21:
 137:matrix.c      ****             timer_elapsed32(matrix_last_modified) > MATRIX_POWER_SAVE) {
 398               		.loc 1 137 0
 399 016e 6091 0000 		lds r22,matrix_last_modified
 400 0172 7091 0000 		lds r23,matrix_last_modified+1
 401 0176 8091 0000 		lds r24,matrix_last_modified+2
 402 017a 9091 0000 		lds r25,matrix_last_modified+3
 403 017e 0E94 0000 		call timer_elapsed32
 404               	.LVL22:
 136:matrix.c      ****              USB_DeviceState == DEVICE_STATE_Unattached ) &&
 405               		.loc 1 136 0
 406 0182 6131      		cpi r22,17
 407 0184 7742      		sbci r23,39
 408 0186 8105      		cpc r24,__zero_reg__
 409 0188 9105      		cpc r25,__zero_reg__
 410 018a 00F0      		brlo .L22
 138:matrix.c      ****         KEY_POWER_OFF();
 139:matrix.c      ****         suspend_power_down();
 411               		.loc 1 139 0
 412 018c 0E94 0000 		call suspend_power_down
 413               	.LVL23:
 414               	.L22:
 140:matrix.c      ****     }
 141:matrix.c      ****     return 1;
 142:matrix.c      **** }
 415               		.loc 1 142 0
 416 0190 81E0      		ldi r24,lo8(1)
 417               	/* epilogue start */
 418 0192 DF91      		pop r29
 419 0194 CF91      		pop r28
 420               	.LVL24:
 421 0196 1F91      		pop r17
 422 0198 0F91      		pop r16
 423 019a 0895      		ret
 424               		.cfi_endproc
 425               	.LFE112:
 427               		.section	.text.matrix_get_row,"ax",@progbits
 428               	.global	matrix_get_row
 430               	matrix_get_row:
 431               	.LFB113:
 143:matrix.c      **** 
 144:matrix.c      **** inline
 145:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 146:matrix.c      **** {
 432               		.loc 1 146 0
 433               		.cfi_startproc
 434               	.LVL25:
 435               	/* prologue: function */
 436               	/* frame size = 0 */
 437               	/* stack size = 0 */
 438               	.L__stack_usage = 0
 147:matrix.c      ****     return matrix[row];
 439               		.loc 1 147 0
 440 0000 E091 0000 		lds r30,matrix
 441 0004 F091 0000 		lds r31,matrix+1
 442 0008 E80F      		add r30,r24
 443 000a F11D      		adc r31,__zero_reg__
 148:matrix.c      **** }
 444               		.loc 1 148 0
 445 000c 8081      		ld r24,Z
 446               	.LVL26:
 447 000e 0895      		ret
 448               		.cfi_endproc
 449               	.LFE113:
 451               		.section	.text.matrix_power_up,"ax",@progbits
 452               	.global	matrix_power_up
 454               	matrix_power_up:
 455               	.LFB114:
 149:matrix.c      **** 
 150:matrix.c      **** void matrix_power_up(void) {
 456               		.loc 1 150 0
 457               		.cfi_startproc
 458               	/* prologue: function */
 459               	/* frame size = 0 */
 460               	/* stack size = 0 */
 461               	.L__stack_usage = 0
 462 0000 0895      		ret
 463               		.cfi_endproc
 464               	.LFE114:
 466               		.section	.text.matrix_power_down,"ax",@progbits
 467               	.global	matrix_power_down
 469               	matrix_power_down:
 470               	.LFB115:
 151:matrix.c      ****     KEY_POWER_ON();
 152:matrix.c      **** }
 153:matrix.c      **** void matrix_power_down(void) {
 471               		.loc 1 153 0
 472               		.cfi_startproc
 473               	/* prologue: function */
 474               	/* frame size = 0 */
 475               	/* stack size = 0 */
 476               	.L__stack_usage = 0
 477 0000 0895      		ret
 478               		.cfi_endproc
 479               	.LFE115:
 481               		.section	.bss._matrix1,"aw",@nobits
 484               	_matrix1:
 485 0000 0000 0000 		.zero	8
 485      0000 0000 
 486               		.section	.bss._matrix0,"aw",@nobits
 489               	_matrix0:
 490 0000 0000 0000 		.zero	8
 490      0000 0000 
 491               		.section	.bss.matrix_prev,"aw",@nobits
 494               	matrix_prev:
 495 0000 0000      		.zero	2
 496               		.section	.bss.matrix,"aw",@nobits
 499               	matrix:
 500 0000 0000      		.zero	2
 501               		.section	.bss.matrix_last_modified,"aw",@nobits
 504               	matrix_last_modified:
 505 0000 0000 0000 		.zero	4
 506               		.text
 507               	.Letext0:
 508               		.file 4 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 509               		.file 5 "../../tmk_core/common/matrix.h"
 510               		.file 6 "../../tmk_core/common/suspend.h"
 511               		.file 7 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/AVR8/../Device.h"
 512               		.file 8 "../../tmk_core/protocol/lufa/LUFA-git/LUFA/Drivers/USB/Core/USBTask.h"
 513               		.file 9 "../../tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:00000000 matrix.c
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:2      *ABS*:0000003e __SP_H__
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:3      *ABS*:0000003d __SP_L__
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:4      *ABS*:0000003f __SREG__
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:6      *ABS*:00000001 __zero_reg__
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:13     .text.matrix_init:00000000 matrix_init
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:489    .bss._matrix0:00000000 _matrix0
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:484    .bss._matrix1:00000000 _matrix1
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:499    .bss.matrix:00000000 matrix
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:494    .bss.matrix_prev:00000000 matrix_prev
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:101    .text.matrix_scan:00000000 matrix_scan
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:504    .bss.matrix_last_modified:00000000 matrix_last_modified
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:430    .text.matrix_get_row:00000000 matrix_get_row
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:454    .text.matrix_power_up:00000000 matrix_power_up
/var/folders/ww/zxgm8pk10vs7h41wm6z_0fjr0000gn/T//cc55qPlk.s:469    .text.matrix_power_down:00000000 matrix_power_down

UNDEFINED SYMBOLS
timer_read32
USB_DeviceState
timer_elapsed32
suspend_power_down
__do_clear_bss
